<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="https://glitch.com/favicon.ico" />

    <script>
      (() => {
        const onScriptLoad = (event) => {
          if (event.target instanceof HTMLScriptElement && event.target.async) {
            window.myAsyncLib.push((lib) => {
              lib.log(
                "capturing load event handler on documentElement (option 8)"
              );
            });
          }
        };
        const options = { capture: true }; // aka useCapture

        // Add capturing load event listener on the Document to detect load events for all elements.
        document.addEventListener("load", onScriptLoad, options);

        // Remove the above listener once the page has loaded, since no longer needed
        // (unless you are going to be adding more async scripts dynamically).
        window.addEventListener(
          "load",
          () => {
            document.removeEventListener("load", onScriptLoad, options);
          },
          { once: true }
        );
      })();
    </script>

    <title>Listening for Loaded Async Script</title>
    <style>
      li {
        margin-bottom: 0.5em;
      }
    </style>
  </head>
  <body>
    <h1>Listening for Loaded Async Script</h1>

    <p>
      This demonstrates a few ways that a blocking non-<code>async</code> script
      can listen for an <code>async</code> script to load:
    </p>
    <ol>
      <li>
        Using the an event system provided by the async library itself, e.g.
        <code>(window.myLib = window.myLib || []).push(callback)</code>.
      </li>
      <li>
        An <code>onload</code> event handler attribute on the
        <code>script[async]</code>. Not ideal since it requires
        <code>'unsafe-hashes'</code> for CSP.
      </li>
      <li>
        <del
          >Adding a <code>load</code> event listener to the
          <code>script[async]</code> which has a defined <code>id</code>. Ideal,
          as long as we can be sure that the <code>script[async]</code> will not
          finish loading <code>before</code> the subsequent inline blocking
          script with <code>script.addEventListener('load', ...)</code> can
          run.</del
        >
        <ins
          ><strong
            >This is not reliable since the async script could load before the
            inline script is executed. See
            <a
              href="https://async-script-load-event-listener-test.glitch.me/?delay=500"
              >demonstration</a
            >.</strong
          ></ins
        >
      </li>
      <li>
        Listening for the <code>readystatechange</code> event until
        <code>document.readyState === 'complete'</code>. The downside here is it
        waits for <em>all</em> async scripts and other assets to have downloaded
        (so similar to the <code>load</code> event on <code>window</code>).
      </li>
      <li>
        The <code>load</code> event on the window. (Worse than
        <code>readystatechange</code>.)
      </li>
      <li>Polling with <code>setInterval</code>. (The worst).</li>
      <li>
        Using <code>MutationObserver</code> to listen for subsquent parsing of
        the <code>script[async]</code> and adding the <code>load</code> event
        via <code>addEventListener</code>. This also works for
        <a href="blocking-script-mutationobserver-load-listener.html"
          >blocking scripts</a
        >! (Props to
        <a href="https://www.linkedin.com/in/noamrosenthal/" target="_blank"
          >Noam Rosenthal</a
        >
        for this approach.)
      </li>
      <li>
        Adding a <code>load</code> event listener on the
        <code>document.documentElement</code> with the
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#:~:text=available%20options%20are%3A-,capture,-Optional"
          ><code>capture</code></a
        >
        option (aka
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#:~:text=with%20the%20listener.-,useCapture,-Optional"
          ><code>useCapture</code></a
        >) set to <code>true</code>. The best?
      </li>
    </ol>

    <p>Did I miss anything?</p>

    <hr />

    <pre id="output"></pre>

    <script id="async-js-before">
      document.getElementById("output").textContent +=
        "ðŸ”µ Inline blocking before script evaluated\n";

      (window.myAsyncLib = window.myAsyncLib || []).push((lib) => {
        lib.log("async library event system (option 1)");
      });

      /*
       * Note: The observer callback will fire twice, once for when the whitespace text node
       * is parsed, and then again when the script element is parsed. The callback ceases to
       * continue being called because it is disconnected as soon as the script detected.
       */
      let mutationObservations = 0;
      new MutationObserver((records, observer) => {
        mutationObservations++;
        const script = document.getElementById("async-js");
        if (script) {
          observer.disconnect();
          script.addEventListener("load", () => {
            window.myAsyncLib.push((lib) => {
              lib.log(
                `script load event via MutationObserver after ${mutationObservations} mutation callback(s) (option 7)`
              );
            });
          });
        }
      }).observe(document.currentScript.parentNode, { childList: true });
    </script>
    <script
      src="/script.js"
      async
      id="async-js"
      onload="document.getElementById('output').textContent += 'ðŸ”µ Async script load event (via onload attribute)\n'; window.myAsyncLib.push((lib) => {lib.log('script onload attribue (option 2)')})"
    ></script>
    <script id="async-js-after">
      document.getElementById("output").textContent +=
        "ðŸ”µ Inline blocking after script evaluated\n";

      // This option is not reliable!
      document.getElementById("async-js").addEventListener("load", () => {
        document.getElementById("output").textContent +=
          "ðŸ”µ Async script load event (from addEventListener)\n";
        window.myAsyncLib.push((lib) => {
          lib.log(
            "script load event via addEventListener (WARNING: not reliable, option 3)"
          );
        });
      });

      document.addEventListener("readystatechange", (event) => {
        document.getElementById(
          "output"
        ).textContent += `ðŸ”µ Ready state change: ${document.readyState}\n`;
        if (document.readyState === "complete") {
          window.myAsyncLib.push((lib) => {
            lib.log("readystatechange event handler (option 4)");
          });
        }
      });

      window.addEventListener("load", () => {
        window.myAsyncLib.push((lib) => {
          lib.log("window load event handler (option 5)");
        });
      });

      const interval = setInterval(() => {
        if (window.myAsyncLib) {
          clearInterval(interval);
          window.myAsyncLib.push((lib) => {
            lib.log("setInterval polling (option 6)");
          });
        }
      }, 10);
    </script>

    <hr />
    <address>
      <a href="https://weston.ruter.net/">@westonruter</a>
    </address>
  </body>
</html>
