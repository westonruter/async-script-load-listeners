<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="https://glitch.com/favicon.ico" />

    <title>Listening for Loaded Async Script</title>
    <style>
      li {
        margin-bottom: 0.5em;
      }
    </style>
  </head>
  <body>
    <h1>Listening for Loaded Async Script</h1>

    <p>
      This demonstrates a few ways that a blocking non-<code>async</code> script
      can listen for an <code>async</code> script to load:
    </p>
    <ol>
      <li>
        Using the an event system provided by the async library itself, e.g.
        <code>(window.myLib = window.myLib || []).push(callback)</code>.
      </li>
      <li>
        An <code>onload</code> event handler attribute on the
        <code>script[async]</code>. Not ideal since it requires
        <code>'unsafe-hashes'</code> for CSP.
      </li>
      <li>
        <del
          >Adding a <code>load</code> event listener to the
          <code>script[async]</code> which has a defined <code>id</code>. Ideal,
          as long as we can be sure that the <code>script[async]</code> will not
          finish loading <code>before</code> the subsequent inline blocking
          script with <code>script.addEventListener('load', ...)</code> can
          run.</del
        >
        <ins
          ><strong
            >This is not reliable since the async script could load before the
            inline script is executed. See
            <a
              href="https://async-script-load-event-listener-test.glitch.me/?delay=500"
              >demonstration</a
            >.</strong
          ></ins
        >
      </li>
      <li>
        Listening for the <code>readystatechange</code> event until
        <code>document.readyState === 'complete'</code>. The downside here is it
        waits for <em>all</em> async scripts and other assets to have downloaded
        (so similar to the <code>load</code> event on <code>window</code>).
      </li>
      <li>
        The <code>load</code> event on the window. (Worse than
        <code>readystatechange</code>.)
      </li>
      <li>Polling with <code>setInterval</code>. (The worst).</li>
      <li>
        Using <code>MutationObserver</code> to listen for appearance of
        subsquent appearance of the <code>script[async]</code> and adding the
        <code>load</code> event via <code>addEventListener</code>. This feels
        like it may not be reliable. Since <code>MutationObserver</code> is
        async it would seem like there could be a possibility that the
        <code>script[async]</code> could be loaded before the
        <code>MutationObserver</code> is triggered. This also feels it could be
        a bit inefficient.
      </li>
    </ol>

    <p>Did I miss anything?</p>

    <hr />

    <pre id="output"></pre>

    <script id="async-js-before">
      document.getElementById("output").textContent +=
        "ðŸ”µ Inline blocking before script evaluated\n";

      (window.myAsyncLib = window.myAsyncLib || []).push((lib) => {
        lib.log("async library event system (option 1)");
      });

      new MutationObserver((records, observer) => {
        const script = document.getElementById("async-js");
        if (script) {
          observer.disconnect();
          script.addEventListener("load", () => {
            window.myAsyncLib.push((lib) => {
              lib.log("script load event via MutationObserver (option 7)");
            });
          });
        }
      }).observe(document.body, { childList: true });
    </script>
    <script
      src="/script.js"
      async
      id="async-js"
      onload="document.getElementById('output').textContent += 'ðŸ”µ Async script load event (via onload attribute)\n'; window.myAsyncLib.push((lib) => {lib.log('script onload attribue (option 2)')})"
    ></script>
    <script id="async-js-after">
      document.getElementById("output").textContent +=
        "ðŸ”µ Inline blocking after script evaluated\n";

      // This option is not reliable!
      document.getElementById("async-js").addEventListener("load", () => {
        document.getElementById("output").textContent +=
          "ðŸ”µ Async script load event (from addEventListener)\n";
        window.myAsyncLib.push((lib) => {
          lib.log("script load event via addEventListener (WARNING: not reliable, option 3)");
        });
      });

      document.addEventListener("readystatechange", (event) => {
        document.getElementById(
          "output"
        ).textContent += `ðŸ”µ Ready state change: ${document.readyState}\n`;
        if (document.readyState === "complete") {
          window.myAsyncLib.push((lib) => {
            lib.log("readystatechange event handler (option 4)");
          });
        }
      });

      window.addEventListener("load", () => {
        window.myAsyncLib.push((lib) => {
          lib.log("window load event handler (option 5)");
        });
      });

      const interval = setInterval(() => {
        if (window.myAsyncLib) {
          clearInterval(interval);
          window.myAsyncLib.push((lib) => {
            lib.log("setInterval polling (option 6)");
          });
        }
      }, 10);
    </script>

    <hr />
    <address>
      <a href="https://weston.ruter.net/">@westonruter</a>
    </address>
  </body>
</html>
